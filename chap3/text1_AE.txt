95p
VAE는 생성 모델링에서 표준 모델이다

97p
오토인코더: 인코딩-디코딩 작업을 수행하도록 훈련된 신경망

옷장 예시에서 포인트는 곧 2D 벡터인데, 이를 디코딩함으로 의류 아이템을 재구성한다
원본 아이템이 없는 위치도 디코딩 가능하므로 이는 곧 생성모델이다

98p
np.pad에서 (0,0), (2,2)등은 해당 차원의 시작과 끝에 각각 추가할 패딩이다
따라서  0 0/2 2/2 2 패딩으로 (60000, 28, 28) -> (60000, 32, 32)가 된다
const 어쩌고는 상수값으로 패딩한다는 뜻, 여기선 제로패딩을 썼다

np.expand_dims는 차원(의 축) 확장 (늘릴 넘파이행렬, 넣을 위치)
넣을 위치에 -1 넣으면 마지막 차원(의 축) 뒤에 추가

100p
임베드의 단어 원뜻은 내포하다, 장착하다, 삽입하다 등의 뜻으로
여기서 임베딩은 원본 이미지를 저차원 잠재 공간으로 압축하는 행위를 의미한다

※ 잡음제거 오토인코더: 노이즈가 낀 데이터를 넣어 원본 데이터를 출력하도록 훈련된 오토인코더
https://sirzzang.github.io/ai/AI-AE-04/

패션엠니스트 실습에서는
인코더로 인풋 -> Conv 3번 -> Flatten -> FC인데
잠재공간은 2차원으로 마지막에서 줄인다

+) 인코더 코드 함수형 API로 되어있는데, 서브 클래싱 API가 제일 낫다고 한다, 걍 파이토치를 쓰자 ㅋㅋ
https://velog.io/@lighthouse97/Tensorflow%EB%A1%9C-%EB%AA%A8%EB%8D%B8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-3%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95

103p
디코더에 쓰는 전치 합성곱 층은 표준 합성곱 층과 다르게 입력 텐서의 w와 h를 '늘린' 상태로 합성곱한다
stride=2로 설정할경우 기존 특성맵을 위아래좌우로늘려 2n+1배로 하며,
여기에 커널을 적용하는것

1. 디코더 코드에서 layers.Dense의 첫번째 인자는 출력 뉴런의 수인데,
np.prod함수에 flatten이전의 shape를 넣었다,
np.prod는 모든 원소를 곱하는 함수로(기본옵션 축고려x 모두 곱해서줌), flatten이후의 출력 크기만큼 출력하도록 만들어준다
입력은 decoder_input에 shape가 (2, )이므로, 입력 2에 출력은 4*4*128인 FC layer가 된다
2. 그다음 Reshape은 Flatten이전의 모양으로 그대로 만들어 주고
3. 전치 합성곱을 3번(필터 수는 역순으로 적용, 나머지 옵션은 그대로)하여
4. 필터수 1(= 출력 채널이 1)이고 표준 합성곱으로 특징 맵을 만들어 준다.
(이 때, 3x3커널, stride 1, same패딩을 쓰므로 결론적으로 w와 h는 변함이 없다)
(활성화 함수로 sigmoid를 쓰더라???)

106p
prediction을 하면 학습된 autoencoder가 재구성 과정을 보여준다
https://webnautes.tistory.com/1892을 참조해서 재구성 전과 후를 지켜보자
위에 문장부터 작업하는것으로 다시시작

109p
새로 생성된 그림은 대부분 재구성이 완벽하지가 않다
인코딩 과정에서 숫자 둘로 축소해서 정보가 손실됐기 때문

어떤 의류종은 다른 의류보다 사실적인데?(잘모르겠다)
잠재공간의 전반적인 포인트 분포에 따른 차이가 있다고한다

책의 예제에서는 다음과 같은 문제가 있다
1. 잠재공간에서 일부 클래스는 매우 작은 영역에 모여있다.
2. 포인트 (0, 0)에 대해 대칭인 분포가 아니고 경계도 없다.
3. 포인트가 거의 없는 색상 사이에는 간격이 매우 크다.

110p
이런 현상을 만들어 낸다
1. 포인트를 균일한 간격으로 뽑아내면 잠재공간이 큰 영역을 디코딩할 가능성이 더 크다
2. 포인트의 분포가 정의된 적이 없으므로 잠재 공간상 랜덤한 포인트의 선택법이 명확하지 않다.
※기술적으로 아무포인트나 뽑아낼 수 있으나 (0, 0)주변에 있을거라는 보장이 없다고 하는데
이게 뭘 의미하는지는 알 수 없음 샘플링에 문재가 된다고함
3. 인코딩 되지 않은 영역(= 구멍)이 있음
공백은 적절한 클래스로 디코딩 할 수가 없음

https://angeloyeo.github.io/2020/10/11/VAE.html
※ ㅅㅂ 여기가 설명을 더 잘해준듯
2번같은경우 feature vector 선택규칙없음 -> 디코딩시 인코더가 space의 어느 좌표에서 해당 데이터를 옮겨 담았는지 매번 확인해서 샘플링이라고 한다.
이건 좀 더 이해가 필요한듯
1번같은경우 오버피팅의 문제